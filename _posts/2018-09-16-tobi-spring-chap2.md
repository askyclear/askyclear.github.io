---
layout: post
title: Apache-Defference 
date: 2018-09-16 22:10:00 -0600
---
토비 스프링 3.1 2장



# 토비의 Spring 3.1 2장 정리

## 테스트

### 테스트란?
 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를  확인해서 내가 만든 코드를 확신할 수 있게 해주는 작업. 
 변화에 유연하게 대처할 수 있는 자신감을 줌
 테스트에 문제가 있다면 코드나 설계에 결함이 있음을 알수 있고 이를 통해 결함을 제거 해 가면서 최종적으로 모든 결함을 제거하는 작업

### 단위테스트
 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트 하는 것이 바람직
 너무 많으면 테스트 수행과정과 정확한 원인 파악이 힘듬
 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만함 범위를 테스트 하는것이 단위 테스트

### 자동수행 테스트 코드
 웹으로 테스트 할 경우 문제가 있을 시 해결 후 다시 테스트 한다고 하면 일련의 동작을 반복해서 해야하는 번거로움이 있다. 코드로 테스트를 자동화 해 둔다면 단지 테스트 코드를 실행 함으로서 이러한 웹상에서 테스트 하는 것의 번거로움을 제거 할 수 있고, 테스트를 자주 할 수 있다는 장점이 있다. 

### 지속적인 개선과 점진적인 개발을 위한 테스트

 개발을 진행 할 때 정상 동작하는 코드를 만들고 이에 대한 테스트 코드를 만들어 둠으로써
 이후 지속적인 개선을 하고  테스트를 수행해 확신을 가지고 코드를 변경 할 수 있기때문에 오히려 개선하는 작업에 속도가 붙을 수 있다는 장점
 새로운 기능을 추가할 때 새로운 테스트도 추가하는 식으로 점진적인 개발을 할 수 있고, 새로운 기능을 추가한 것이 기존 코드에 영향을 주지 않고 잘 동작하는지 확인 할 수 있는 장점


### 1장 테스트 코드 개선 하기
 1장에서의 테스트 코드
 
 ![1장테스트코드](/images/chap1_testcode.PNG)

#### 문제점
 - 수동확인 작업의 번거로움(입력한 값과 가져온 값이 일치하는 코드가 없음)
 - 실행작업의 번거로움 (main 메소드를 계속 실행해야함 테스트가 많을경우 일일히 수행해야함)

#### 테스트 검증의 자동화

 ![2장테스트검증자동화](/images/chap2_automatic1.PNG)

테스트의 수행의 자동화에서 테스트 값 적용, 결과를 검증하는것까지 자동화 함으로써 UserDao의 두가지 기능이 정상적으로 동작하는지를 언제든지 쉽게 확인할 수 있다.

"테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"  - by 켄트 벡

### 테스트의 효율적인 수행과 결과 관리
main 메소드만으로 테스트 하기에는 한계가 있으므로 테스트 결과를 종합해서 볼 수 있고, 테스트가 실패한 곳을 빠르게  찾을 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요해짐.

#### JUnit 적용하기
 자바에서 제공하는 테스트를 위한 도구
 
 ![기존코드Junit으로변경](/images/chap2_automatic2.PNG)

 - 다른 main 메소드에서 JUnitCore를 통해 실행 시킬수 있음.

```
JUnitCore.main("com.nts.spring.study.pp1.UserTest");
```
 - ide를 통해서도 확인 가능
 - 빌드 툴 : CI(지속적인통합) 인 젠킨스를 통해 확인하는것을 말하는 듯

#### 테스트 결과의 일관성
 현재까지 진행 사항으로는 매번 DB에서 데이터를 삭제해야 테스트의 결과가 성공한다는 점이 문제
 단위테스트는 코드의 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다(외부 환경에 영향을 받지 말아야함)

 - 이를 위해 deleteAll 과 getCount 기능을 추가한다. 
 
 ![일관성을 위한 테스트 코드](/images/chap2_automatic3.PNG)

 이런 방법보다 뒤에서 설명한다고 하는데 트랜잭션을 말하는 것 같다. 현 단계에서는 아직 안함

 - 테스트는 한가지의 결과만 검증하고 마는 것은 상당히 위험함 조금더 보강된 테스트 가 필요
 
    ![보강된 테스트 코드](/images/chap2_automatic4.PNG "addAndGet의 보강된 테스트")
    
    ![보강된 테스트 코드](/images/chap2_automatic5.PNG "getCount의 보강된 테스트")

 - get() 메소드 실행시 데이터가 없을때
 * null이나 특정 값을 return 하거나 예외를 발생시킴. 책에서는 예외를 발생시키는 것으로
 
 ![예외 던짐 테스트](/images/chap2_exceptionTest1.PNG "get의 예외던짐 테스트")

 이것만 추가 하면 당연히 테스트는 실패한다 dao에 예외를 던진다고 하지 않았으니 말이다. 이 테스트를 통과 시키기 위해 UserDao를 수정 한다.
 
  ![예외 던짐 테스트DAO 수정](/images/chap2_exceptionTest2.PNG "get의 예외던짐 테스트")

 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다. 왜냐면 개발자는 항상 잘 돌아가는 케이스를 생각하면서 코드를 만드는 것이 일반적이고 이때문에 테스트를 작성할때에도 교묘히 실패할만한 케이스를 피하면서 작성하기 때문이다. 그래서 이런 변명이 잘 나온다 "내 PC에서는 잘되는데..."



### TDD 주도개발(Test Driven Development)
 get 메소드의 예외  테스트를 만드는 순서를 보면 일단 새로운 기능을 넣기 위해 테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao를 수정 하였다. 
 테스트 코드를 보면 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되 있을 것인데 이는 하나의 기능정의서처럼 보인다. 테스트 코드를 작성 후 실제 기능을 구현 한 후 테스트를 했을때 통과 한다면 잘 구현한 것이고 아니라면 테스트 코드의 실행으로 문제를 확인하고 다시 수정을 가할 수 있다. 
 - "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다." 기본원칙
 - 테스트를 빼먹지 않고 꼼꼼하게 만들 수 있음 (코드에 대한 확신, 마음의 여유)
 - 테스트 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게
 - 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 장점

### JUnit의 테스트 수행방식
 1. 테스트 클래스에서  @Test 이고 public void형이며 파라미터가 없는  메소드 찾기
 2. 테스트 클래스의 오브젝트를 하나 만듬
 3. @Before가 붙은 메소드 실행
 4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과 저장
 5. @After가 붙은 메소드 실행
 6. 나머지 테스트 메소드를 2~5 과정으로 실행
 7. 모든  테스트의 결과를 종합해서 return

### 픽스쳐
테스트를 수행하는 데 필요한 정보나 오브젝트
현 과정에서 UserDaoTest에서는 dao가 각 테스트 메소드에서 많이 사용되는 User 오브젝트들을 말함
이러한 픽스쳐들은 @Before 에서 생성하도록 만듬

 ![픽스쳐 및 Before 사용](/images/chap2_junit.PNG "get의 예외던짐 테스트")

### 스프링  테스트 적용
@RunWith :  JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용
@ContextConfiguration : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치
이를 통해 생성한 ApplicationContext는 모든 테스트에서 같은 객체

@Autowired : 스프링DI에 사용되는 특별한 어노테이션. VOL.2에서 자세히....
 - 동일한 타입의 bean이 2개 이상 있는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인하고 변수이름으로도 찾을 수 없는 경우 예외 발생
 
 ![spring app context  간편 적용](/images/chap2_springTest.PNG )

#### DI와 테스트
인터페이스를 두고 DI를 적용해야 하는 이유 
 - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문.
 - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문. 이런 기능을 일반화해 AOP라는 기술로 만들었음
 - 효율적인 테스트를 위해

#### test 환경에 알맞는 DI를 설정하는 방법
1. @DirtiesContext 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는것을 테스트 컨텍스트 프레임워크에 알려주고, DI 부분만 직접 추가

![spring app context  간편 적용](/images/chap2_springTest2.PNG )

2. 다른 설정 파일을 만들어서 적용 : 테스트용 config 을 만들어서 적용

![spring app context  간편 적용](/images/chap2_springTest3.PNG )

3. 컨테이너 없는 DI 테스트 : 직접적으로 DI를 직접 행함
별다른 @AutoWired 등의 어노테이션 없이 직접적으로 생성하고 관계설정등을 해주는것

- 셋중 좋은 방법은 ? 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려(3) 여러 오브젝트와 복잡한 의종관계를 갖고 있는 오브젝트를 테스트해야할 경우에는 DI 방식의 테스트(2) 고려


### 학습 테스트로 배우는 스프링
 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 테스트를 작성하는 것을 학습 테스트(learning test)라 함
 #### 목적
 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것.
 #### 장점
  - 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있음(예제를 만들어서 학습하는 것은 수동 테스트와 성격이 비슷하여 느린 동작확인이지만 학습테스트는 빠르게 확인 가능)
  - 학습 테스트 코드를 개발 중에 참고할 수 있음(에제 만드는 것은 최종본만 남지만 학습테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 남겨둘 수 있음)
  - 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와줌 ( 업그레이드 전에 테스트 코드에만 먼저 적용하여 잘 동작하는지 확인할 수 있음 만약 문제가 잇을경우 실제 적용시 어떻게 수정해야 할지 미리 대비가 가능함)
  - 테스트 작성에 대한 좋은 훈련이 됨(많이 작성하니 연습이 됨..)
  - 새로운 기술을 공부하는 과정이 즐거워 짐(문서 읽는것보다 실습이 더 재미남)

%스프링 자신의 테스트 코드 참조를 하면 도움이 된다고 합니다...%


### 버그 테스트
코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말함.
오류가 발견되었다고 했을때 무턱대고 코드를 뒤져가면서 수정하려고 하기 보다는 버그테스트를 만들어 보는 것이 유용
 일단 버그가 원인이 되서 테스트가 실패하는 코드를 만들고 그 이후 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정함으로서 해결
 #### 장점
 - 테스트의 완성도를 높여줌(기존 테스트에서 검증하지 못한 부분이 있기에 버그가 발생한 것임 이를 행결함으로써 불충분한 테스트를 보완해주고 비슷한 문제가 다시 등장하더라도 쉽게 추적 가능)
 - 버그의 내용을 명확하게 분석(버그 테스트를 만들려면 어떤 이유 때문에 실패했는지 명확히 알아야 하기 때문에 효과적으로 분석할수 있다고 함 이를 통해 다른 오류도 함께 캐치 할수도 있음)
 - 기술적인 문제를 해결하는데 도움(정확한 원인을 파악하기 힘들때 동일한 문제를 일으키는 가장 단순함 코드와 그에 대한 버그 테스트를 만들어 보면 도움이 된다고 함. 정 모르면 커뮤니티 등을 통해 도움을 얻을때도 좋다고 함)

% 동등분할
같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법 결과가 총 3가지라면 그 3가지 결과를 낼 수 있는 입력 값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 하는것

% 경계값 분석
에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해 경계의 근처에 있는 값을 이용해 테스트하는 방법 숫자 입력값인 경우 0 또는 그 주변값 또는 정수의 최대값 최소값으로 테스트
